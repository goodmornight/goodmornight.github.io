<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="ES6规范 [ GoodNight ] "><meta name="theme-color" content="#ebc65a"><title>ES6规范 [ GoodNight ] </title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><script src="https://cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><script src="https://www.googletagmanager.com/gtag/js?id=UA-171806323-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-171806323-1');</script><link rel="stylesheet" href="/css/tocbot.css"><script src="/js/tocbot.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: true,
    orderedList: false,
    collapseDepth: 2,
  });
})</script><link rel="preload" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">GoodNight</a></h1><p>Take A Rest</p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><p class="text">ES6规范</p><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">ES6规范</a></h2><span class="post__date">2020-07-03</span><a href="/tags/ES6/"><span class="post__tags">#ES6</span></a><a href="/tags/Javascript/"><span class="post__tags">#Javascript</span></a></div></div><div class="article__content"><p>以下内容，根据参考链接是参考Airbnb公司的JavaScript风格规范，我在此记录只为加深记忆。坚持ESLint代码风格。保持良好的代码风格，一方面是方便自己查看之前写过的代码，方便更新维护，另一方面是方便接手你代码的人。每个团队都有自己的代码规范，团队共同开发，保持一致的代码规范，是维持关系的基础。<del>（以上都是我瞎说的）</del></p>
<h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h1><h2 id="1-块级作用域"><a href="#1-块级作用域" class="headerlink" title="1.块级作用域"></a>1.块级作用域</h2><h3 id="1-let替换var"><a href="#1-let替换var" class="headerlink" title="(1) let替换var"></a>(1) let替换var</h3><p><code>let</code>的特点是不会变量提升，而是被锁在当前块中。</p>
<p>唯一正确的使用方法：<strong>先声明，再访问</strong>。</p>
<h3 id="2-全局常量const"><a href="#2-全局常量const" class="headerlink" title="(2) 全局常量const"></a>(2) 全局常量const</h3><p>声明常量，一旦声明，不可更改，而且常量必须初始化赋值。</p>
<p>const虽然是常量，不允许修改默认赋值，但如果定义的是对象Object，那么可以修改对象内部的属性值。</p>
<p><code>const</code>优于<code>let</code>有几个原因。一个是<code>const</code>可以提醒阅读程序的人，这个变量不应该改变；另一个是<code>const</code>比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对<code>const</code>进行优化，所以多使用<code>const</code>，有利于提高程序的运行效率，也就是说<code>let</code>和<code>const</code>的本质区别，其实是编译器内部的处理不同。</p>
<p><code>const</code>声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。</p>
<p><strong>所有的函数都应该设置为常量。</strong>（对于这句话我还存在疑问）</p>
<p>长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时<code>let</code>表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> c = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// best</span><br><span class="hljs-keyword">const</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>

<h3 id="3-const和let异同点"><a href="#3-const和let异同点" class="headerlink" title="(3) const和let异同点"></a>(3) const和let异同点</h3><p>相同点：const和let都是在当前块内有效，执行到块外会被销毁，也不存在变量提升（TDZ），不能重复声明。<br>不同点：const不能再赋值，let声明的变量可以重复赋值。</p>
<p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h2><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-string">"foobar"</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-string">'foo'</span> + a + <span class="hljs-string">'bar'</span>;<br><br><span class="hljs-comment">// acceptable</span><br><span class="hljs-keyword">const</span> c = <span class="hljs-string">`foobar`</span>;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-string">'foobar'</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-string">`foo<span class="hljs-subst">$&#123;a&#125;</span>bar`</span>;<br></code></pre></td></tr></table></figure>

<p>ES6引入了模板字符串的特性，用反引号来表示，可以表示多行字符串以及做到文本插值（利用模板占位符）。(这块内容的实现还是有点懵)</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># ES5</span><br>console.<span class="hljs-built_in">log</span>('hello\n\<br>world')<br><span class="hljs-meta"># ES6</span><br>console.<span class="hljs-built_in">log</span>(`hello<br>world`)<br></code></pre></td></tr></table></figure>

<p><img src="https://mdpic-1258411264.cos.ap-shanghai.myqcloud.com/night/202007/03/173249-179422.png" alt="image-20200703173037602"></p>
<p>可以用${}来表示模板占位符，可以将你已经定义好的变量传进括弧中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">'night'</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello $&#123;name&#125;'</span>)<br></code></pre></td></tr></table></figure>

<h2 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3.解构赋值"></a>3.解构赋值</h2><p>使用<strong>数组</strong>成员对变量赋值时，优先使用解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">const</span> first = arr[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">const</span> second = arr[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">const</span> [first, second] = arr;<br></code></pre></td></tr></table></figure>

<p>函数的参数如果是<strong>对象</strong>的成员，优先使用解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFullName</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> firstName = user.firstName;<br>  <span class="hljs-keyword">const</span> lastName = user.lastName;<br>&#125;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFullName</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; firstName, lastName &#125; = obj;<br>&#125;<br><br><span class="hljs-comment">// best</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFullName</span>(<span class="hljs-params">&#123; firstName, lastName &#125;</span>) </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果函数返回多个值，<strong>优先使用对象的解构赋值</strong>，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processInput</span>(<span class="hljs-params">input</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> [left, right, top, bottom];<br>&#125;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processInput</span>(<span class="hljs-params">input</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123; left, right, top, bottom &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> &#123; left, right &#125; = processInput(input);<br></code></pre></td></tr></table></figure>

<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">MDN–解构赋值(详细介绍)</a></p>
<h2 id="4-对象"><a href="#4-对象" class="headerlink" title="4.对象"></a>4.对象</h2><p><strong>单行定义的对象，最后一个成员不以逗号结尾。</strong></p>
<p><strong>多行定义的对象，最后一个成员以逗号结尾。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">const</span> a = &#123; <span class="hljs-attr">k1</span>: v1, <span class="hljs-attr">k2</span>: v2, &#125;;<br><span class="hljs-keyword">const</span> b = &#123;<br>  k1: v1,<br>  k2: v2<br>&#125;;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">const</span> a = &#123; <span class="hljs-attr">k1</span>: v1, <span class="hljs-attr">k2</span>: v2 &#125;;<br><span class="hljs-keyword">const</span> b = &#123;<br>  k1: v1,<br>  k2: v2,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">const</span> a = &#123;&#125;;<br>a.x = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// if reshape unavoidable</span><br><span class="hljs-keyword">const</span> a = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.assign(a, &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">3</span> &#125;);<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">const</span> a = &#123; <span class="hljs-attr">x</span>: <span class="hljs-literal">null</span> &#125;;<br>a.x = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>

<p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  id: <span class="hljs-number">5</span>,<br>  name: <span class="hljs-string">'San Francisco'</span>,<br>&#125;;<br>obj[getKey(<span class="hljs-string">'enabled'</span>)] = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  id: <span class="hljs-number">5</span>,<br>  name: <span class="hljs-string">'San Francisco'</span>,<br>  [getKey(<span class="hljs-string">'enabled'</span>)]: <span class="hljs-literal">true</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>的最后一个属性名，需要计算得到。这时最好采用<strong>属性表达式</strong>，在新建<code>obj</code>的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。</p>
<p>另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ref = <span class="hljs-string">'some value'</span>;<br><br><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">const</span> atom = &#123;<br>  ref: ref,<br><br>  value: <span class="hljs-number">1</span>,<br><br>  addValue: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> atom.value + value;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">const</span> atom = &#123;<br>  ref,<br><br>  value: <span class="hljs-number">1</span>,<br><br>  addValue(value) &#123;<br>    <span class="hljs-keyword">return</span> atom.value + value;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="扩展：属性表达式"><a href="#扩展：属性表达式" class="headerlink" title="扩展：属性表达式"></a>扩展：属性表达式</h3><p>JavaScript语言定义对象的属性，有两种方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-comment">// 方法一</span><br>obj.foo = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 方法二</span><br>obj[<span class="hljs-string">'a'</span>+<span class="hljs-string">'bc'</span>] = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">document</span>.write(obj);<br></code></pre></td></tr></table></figure>

<p>上面代码的方法一是直接用<em>标识符</em>作为属性名，方法二是用<em>表达式</em>作为属性名，这时要将表达式放在方括号之内。</p>
<p>如果使用字面量方式定义对象（使用大括号），在ES5中只能使用方法一（<em>标识符</em>）定义属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  foo: <span class="hljs-literal">true</span>,<br>  abc: <span class="hljs-number">123</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>ES6允许字面量定义对象时，用方法二（<em>表达式</em>）作为对象的属性名，即把表达式放在方括号内。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> propKey = <span class="hljs-string">'foo'</span>;<br><br><span class="hljs-keyword">let</span> obj = &#123;<br>   [propKey]: <span class="hljs-literal">true</span>,<br>   [<span class="hljs-string">'a'</span>+<span class="hljs-string">'bc'</span>]: <span class="hljs-number">123</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>表达式还可以用于定义方法名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  [<span class="hljs-string">'h'</span>+<span class="hljs-string">'ello'</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'hi'</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">document</span>.write(obj.hello()); <span class="hljs-comment">// hi</span><br></code></pre></td></tr></table></figure>

<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h2><p>使用<strong>扩展运算符（…）</strong>拷贝数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">const</span> len = items.length;<br><span class="hljs-keyword">const</span> itemsCopy = [];<br><span class="hljs-keyword">let</span> i;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>  itemsCopy[i] = items[i];<br>&#125;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">const</span> itemsCopy = [...items];<br></code></pre></td></tr></table></figure>

<p>使用 Array.from 方法，将类似数组的对象转为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.foo'</span>);<br><span class="hljs-keyword">const</span> nodes = <span class="hljs-built_in">Array</span>.from(foo);<br></code></pre></td></tr></table></figure>

<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6.函数"></a>6.函数</h2><p>立即执行函数、匿名函数可写成箭头函数形式。<strong>简单的、单行的、不会复用的函数，建议采用箭头函数。</strong>如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Welcome to the Internet.'</span>);<br>&#125;)();<br><br><span class="hljs-comment">// bad</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x * x;<br>&#125;);<br><br><span class="hljs-comment">// good</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> x * x;<br>&#125;);<br><br><span class="hljs-comment">// best</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x);<br></code></pre></td></tr></table></figure>

<p>箭头函数取代<code>Function.prototype.bind</code>，不应再用 self/_this/that 绑定 this。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">const</span> boundMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...params</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> method.apply(self, params);<br>&#125;<br><br><span class="hljs-comment">// acceptable</span><br><span class="hljs-keyword">const</span> boundMethod = method.bind(<span class="hljs-keyword">this</span>);<br><br><span class="hljs-comment">// best</span><br><span class="hljs-keyword">const</span> boundMethod = <span class="hljs-function">(<span class="hljs-params">...params</span>) =&gt;</span> method.apply(<span class="hljs-keyword">this</span>, params);<br></code></pre></td></tr></table></figure>

<p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。(这个不是很理解)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">divide</span>(<span class="hljs-params">a, b, option = false </span>) </span>&#123;<br>&#125;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">divide</span>(<span class="hljs-params">a, b, &#123; option = false &#125; = &#123;&#125;</span>) </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">concatenateAll</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);<br>  <span class="hljs-keyword">return</span> args.join(<span class="hljs-string">''</span>);<br>&#125;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">concatenateAll</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> args.join(<span class="hljs-string">''</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用默认值语法设置函数参数的默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleThings</span>(<span class="hljs-params">opts</span>) </span>&#123;<br>  opts = opts || &#123;&#125;;<br>&#125;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleThings</span>(<span class="hljs-params">opts = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-Map结构"><a href="#7-Map结构" class="headerlink" title="7.Map结构"></a>7.Map结构</h2><p>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要<code>key: value</code>的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。（暂时不是很理解）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(arr);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> map.keys()) &#123;<br>  <span class="hljs-built_in">console</span>.log(key);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> map.values()) &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> map.entries()) &#123;<br>  <span class="hljs-built_in">console</span>.log(item[<span class="hljs-number">0</span>], item[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-Class"><a href="#8-Class" class="headerlink" title="8.Class"></a>8.Class</h2><p>总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。(暂时没用过)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Queue</span>(<span class="hljs-params">contents = []</span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>._queue = [...contents];<br>&#125;<br>Queue.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> value = <span class="hljs-keyword">this</span>._queue[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">this</span>._queue.splice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(contents = []) &#123;<br>    <span class="hljs-keyword">this</span>._queue = [...contents];<br>  &#125;<br>  pop() &#123;<br>    <span class="hljs-keyword">const</span> value = <span class="hljs-keyword">this</span>._queue[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">this</span>._queue.splice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用<code>extends</code>实现继承，因为这样更简单，不会有破坏<code>instanceof</code>运算的危险。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">const</span> inherits = <span class="hljs-built_in">require</span>(<span class="hljs-string">'inherits'</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PeekableQueue</span>(<span class="hljs-params">contents</span>) </span>&#123;<br>  Queue.apply(<span class="hljs-keyword">this</span>, contents);<br>&#125;<br>inherits(PeekableQueue, Queue);<br>PeekableQueue.prototype.peek = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._queue[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeekableQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span> </span>&#123;<br>  peek() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._queue[<span class="hljs-number">0</span>];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="9-模块"><a href="#9-模块" class="headerlink" title="9.模块"></a>9.模块</h2><p>首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用<code>import</code>取代<code>require</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">const</span> moduleA = <span class="hljs-built_in">require</span>(<span class="hljs-string">'moduleA'</span>);<br><span class="hljs-keyword">const</span> func1 = moduleA.func1;<br><span class="hljs-keyword">const</span> func2 = moduleA.func2;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">import</span> &#123; func1, func2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'moduleA'</span>;<br></code></pre></td></tr></table></figure>

<p>使用<code>export</code>取代<code>module.exports</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// commonJS的写法</span><br><span class="hljs-keyword">var</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react'</span>);<br><br><span class="hljs-keyword">var</span> Breadcrumbs = React.createClass(&#123;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> /&gt;</span></span>;<br>  &#125;<br>&#125;);<br><br><span class="hljs-built_in">module</span>.exports = Breadcrumbs;<br><br><span class="hljs-comment">// ES6的写法</span><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Breadcrumbs</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> /&gt;</span></span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Breadcrumbs;<br></code></pre></td></tr></table></figure>

<p>如果模块只有一个输出值，就使用<code>export default</code>，如果模块有多个输出值，就不使用<code>export default</code>，<code>export default</code>与普通的<code>export</code>不要同时使用。</p>
<p>不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> myObject <span class="hljs-keyword">from</span> <span class="hljs-string">'./importModule'</span>;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">import</span> myObject <span class="hljs-keyword">from</span> <span class="hljs-string">'./importModule'</span>;<br></code></pre></td></tr></table></figure>

<p>如果模块默认输出一个函数，函数名的首字母应该小写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeStyleGuide</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> makeStyleGuide;<br></code></pre></td></tr></table></figure>

<p>如果模块默认输出一个对象，对象名的首字母应该大写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> StyleGuide = &#123;<br>  es6: &#123;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> StyleGuide;<br></code></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://es6.ruanyifeng.com/?search=%26%26&x=15&y=10#docs/style" target="_blank" rel="noopener">ECMAScript6–编程风格</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/43890979" target="_blank" rel="noopener">知乎–关于工作中常用到的ES6语法</a></p>
<p><a href="http://cw.hubwiz.com/card/c/5594e91ac086935f4a6fb8ef/1/5/2/" target="_blank" rel="noopener">汇智网–属性名表达式</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">MDN–解构赋值(详细介绍)</a></p>
</div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Links</h2><div class="sidebar__link"><ul><li><a href="https://github.com/GoodNight-Git" target="_blank" rel="noopener">Github</a></li><li><a href="https://juejin.im/user/5cb1ed9b5188251b090acc5c" target="_blank" rel="noopener">掘金</a></li><li><a href="mailto:goodnightlilanhui@gmail.com">Mail</a></li></ul></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/about/">about</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/notes/">notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/plans/">plans</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/projects/">projects</a></li></ul></div><h2>Tags</h2><div class="sidebar__tags"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Axios/" rel="tag">Axios</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Coding-net/" rel="tag">Coding.net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CodingThinking/" rel="tag">CodingThinking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Color/" rel="tag">Color</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/" rel="tag">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali-2-0/" rel="tag">Kali 2.0</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Keycloak/" rel="tag">Keycloak</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenCV/" rel="tag">OpenCV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python-Web/" rel="tag">Python Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/" rel="tag">Qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL-Server/" rel="tag">SQL Server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Translation/" rel="tag">Translation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UI/" rel="tag">UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu%E7%B3%BB%E7%BB%9F/" rel="tag">Ubuntu系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VUE/" rel="tag">VUE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Win10/" rel="tag">Win10</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keycloak/" rel="tag">keycloak</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/taro/" rel="tag">taro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%A7%E5%93%81/" rel="tag">产品</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E6%8E%A8/" rel="tag">内推</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%BA%8A/" rel="tag">图床</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%92%E6%AD%A6%E7%BA%AA%E9%A1%B9%E7%9B%AE/" rel="tag">寒武纪项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BB%BA%E7%AB%99/" rel="tag">建站</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E9%A1%B9/" rel="tag">杂项</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" rel="tag">碎碎念</a></li></ul></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button" href="/2020/07/03/Hexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0+%E6%A8%A1%E7%89%88%E8%AE%BE%E7%BD%AE/">Hexo新建文章+模版设置</a><a class="next-button" href="/2020/07/03/exports-module-exports%E5%92%8Cexport-export-default/">exports/module.exports和export/export default???</a></div></div></div></div><div class="footer"><span>©️2019-2020 </span><p>Designed By&nbsp;<strong><a href="https://github.com/random-yang" target="_blank" rel="noopener">RandomYang</a></strong></p><p>Changed By<strong><a href="http://www.goodnight.wiki" target="_blank" rel="noopener">GoodNight</a></strong></p><p>Powered By&nbsp;<strong><a href="https://hexo.io" target="_blank" rel="noopener">hexo</a></strong></p><p><div id="beian"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61019002001135" target="_blank" rel="noopener"><img src="../img/beian.png"><span>陕公网安备 61019002001135号&nbsp;</span></a></div><div id="tengxun"><a href="http://beian.miit.gov.cn" target="_blank" rel="noopener">陕ICP备20010639号</a></div></p></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>